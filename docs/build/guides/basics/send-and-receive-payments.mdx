---
title: Send and receive payments
sidebar_position: 20
description: Learn to send payments and watch for received payments on the Stellar network
---

import { CodeExample } from "@site/src/components/CodeExample";
import { Alert } from "@site/src/components/Alert";

Most of the time, you’ll be sending money to someone else who has their own account. For this tutorial, however, you'll need a second account to transact with. So before proceeding, follow the steps outlined in [Create an Account](./create-account.mdx) to make _two_ accounts: one for sending and one for receiving.

## About Operations and Transactions

Actions that do things on Stellar — like sending payments or making buy or sell offers — are called [operations](../../../learn/fundamentals/transactions/operations-and-transactions.mdx#operations). To submit an operation to the network, you bundle it into a [transaction](../../../learn/fundamentals/transactions/operations-and-transactions.mdx#transactions), which is a group of anywhere from 1 to 100 operations accompanied by some extra information, like which account is making the transaction and a cryptographic signature to verify that the transaction is authentic.

Transactions are atomic, meaning that if any operation in a transaction fails, they all fail. Let’s say you have 100 lumens and you make two payment operations of 60 lumens each. If you make two transactions (each with one operation), the first will succeed and the second will fail because you don’t have enough lumens. You’ll be left with 40 lumens. However, if you group the two payments into a single transaction, they will both fail and you’ll be left with the full 100 lumens still in your account.

Every transaction also incurs a small fee. Like the minimum balance on accounts, this fee deters spam and prevents people from overloading the system. This [base fee](../../../learn/fundamentals/fees-resource-limits-metering.mdx) is very small — 100 stroops per operation where a stroop equals 1 \* 10 ^-7 XLM — and it's charged for each operation in a transaction. A transaction with two operations, for instance, would cost 200 stroops.

With the recent addition of Soroban and smart contracts, Stellar also supports a different way of executing transactions. These use a specific type of operation (`invokeHostFunction`) to invoke a smart contract function, and this contract carries the logic that executes custom functionality and/or payments. By default, all classic assets on Stellar can be represented by a default smart contract called a [Stellar Asset Contract (SAC)](../../../tokens/stellar-asset-contract.mdx), which provides a standardized interface for asset operations through contract logic.

For the purpose of this guide, the payment examples will be segregated between **Classic Payments** (using built-in operations like the traditional `payment` operation) and **SAC Payments** (which make use of the default smart contract and execute payments through contract logic).

Additionally, there are two main options to interact with the Stellar network: the [Horizon API](../../../data/apis/horizon/README.mdx) and [Stellar RPC](../../../data/apis/rpc/README.mdx). Each payment example will be broken down to show how to perform such payments with either option.

<Alert>

In the following code samples, proper error checking is omitted for brevity. However, you should _always_ validate your results, as there are many ways that requests can fail. You should refer to the guide on [Error Handling](../../../data/apis/horizon/api-reference/errors/error-handling.mdx) for tips on error management strategies.

</Alert>

## Classic Payments

### Send a Payment

When sending payments on Stellar, you build a transaction with a payment operation, sign it, and submit it to the network. Stellar stores and communicates transaction data in a binary format called [XDR](../../../learn/encyclopedia/data-format/xdr.mdx), which is optimized for network performance but unreadable to the human eye. Luckily, [Horizon API](../../../data/apis/horizon/README.mdx), [Stellar RPC](../../../data/apis/rpc/README.mdx), and the [Stellar SDKs](../../../tools/sdks/README.mdx) convert XDRs into friendlier formats. Here’s how you might send 10 lumens to an account:

#### Using the Stellar RPC

<CodeExample>

```js
var StellarSdk = require("stellar-sdk");

const rpc = new StellarSdk.rpc.Server("https://soroban-testnet.stellar.org");
const sourceKeys = StellarSdk.Keypair.fromSecret(
  "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4",
);
const destinationId = "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5";
let transaction;

// First, check to make sure that the destination account exists.
rpc
  .getAccount(destinationId)
  .catch(function (error) {
    if (error instanceof StellarSdk.NotFoundError) {
      throw new Error("The destination account does not exist!");
    } else return error;
  })
  .then(function () {
    return rpc.getAccount(sourceKeys.publicKey());
  })
  .then(function (sourceAccount) {
    transaction = new StellarSdk.TransactionBuilder(sourceAccount, {
      fee: StellarSdk.BASE_FEE,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    })
      .addOperation(
        StellarSdk.Operation.payment({
          destination: destinationId,
          asset: StellarSdk.Asset.native(),
          amount: "10",
        })
      )
      .addMemo(StellarSdk.Memo.text("Test Transaction"))
      .setTimeout(180)
      .build();

    transaction.sign(sourceKeys);

    return rpc
      .sendTransaction(transaction)
      .then(async (reply) => {
        if (reply.status !== "PENDING") {
          throw reply;
        }

        return rpc.pollTransaction(reply.hash, {
          sleepStrategy: (_iter: number) => 500,
          attempts: 5,
        });
      })
      .then((finalStatus) => {
        switch (finalStatus.status) {
          case StellarSdk.rpc.Api.GetTransactionStatus.FAILED:
          case StellarSdk.rpc.Api.GetTransactionStatus.NOT_FOUND:
            throw new Error(`Transaction failed with status: ${finalStatus.status}`);
          case StellarSdk.rpc.Api.GetTransactionStatus.SUCCESS:
            return finalStatus;
        }
      });
  })
  .then(function (result) {
    console.log("Success! Results:", result);
  })
  .catch(function (error) {
    console.error("Something went wrong!", error);
  });
```

</CodeExample>

The key differences when using RPC instead of Horizon:

1. **Instant submission**: `rpc.sendTransaction()` returns immediately with a "PENDING" status
2. **Active polling required**: You must poll `rpc.pollTransaction()` to get the final result
3. **Polling configuration**: You can customize polling intervals and retry attempts
4. **Status handling**: Check for SUCCESS, FAILED, or NOT_FOUND status in the final result

#### Using the Horizon API

<CodeExample>

```js
var StellarSdk = require("stellar-sdk");
var server = new StellarSdk.Horizon.Server(
  "https://horizon-testnet.stellar.org",
);
var sourceKeys = StellarSdk.Keypair.fromSecret(
  "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4",
);
var destinationId = "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5";
// Transaction will hold a built transaction we can resubmit if the result is unknown.
var transaction;

// First, check to make sure that the destination account exists.
// You could skip this, but if the account does not exist, you will be charged
// the transaction fee when the transaction fails.
server
  .loadAccount(destinationId)
  // If the account is not found, surface a nicer error message for logging.
  .catch(function (error) {
    if (error instanceof StellarSdk.NotFoundError) {
      throw new Error("The destination account does not exist!");
    } else return error;
  })
  // If there was no error, load up-to-date information on your account.
  .then(function () {
    return server.loadAccount(sourceKeys.publicKey());
  })
  .then(function (sourceAccount) {
    // Start building the transaction.
    transaction = new StellarSdk.TransactionBuilder(sourceAccount, {
      fee: StellarSdk.BASE_FEE,
      networkPassphrase: StellarSdk.Networks.TESTNET,
    })
      .addOperation(
        StellarSdk.Operation.payment({
          destination: destinationId,
          // Because Stellar allows transaction in many currencies, you must
          // specify the asset type. The special "native" asset represents Lumens.
          asset: StellarSdk.Asset.native(),
          amount: "10",
        }),
      )
      // A memo allows you to add your own metadata to a transaction. It's
      // optional and does not affect how Stellar treats the transaction.
      .addMemo(StellarSdk.Memo.text("Test Transaction"))
      // Wait a maximum of three minutes for the transaction
      .setTimeout(180)
      .build();
    // Sign the transaction to prove you are actually the person sending it.
    transaction.sign(sourceKeys);
    // And finally, send it off to Stellar!
    return server.submitTransaction(transaction);
  })
  .then(function (result) {
    console.log("Success! Results:", result);
  })
  .catch(function (error) {
    console.error("Something went wrong!", error);
    // If the result is unknown (no response body, timeout etc.) we simply resubmit
    // already built transaction:
    // server.submitTransaction(transaction);
  });
```

```java
Server server = new Server("https://horizon-testnet.stellar.org");

KeyPair source = KeyPair.fromSecretSeed("SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4");
KeyPair destination = KeyPair.fromAccountId("GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5");

// First, check to make sure that the destination account exists.
// You could skip this, but if the account does not exist, you will be charged
// the transaction fee when the transaction fails.
// It will throw HttpResponseException if account does not exist or there was another error.
server.accounts().account(destination.getAccountId());

// If there was no error, load up-to-date information on your account.
AccountResponse sourceAccount = server.accounts().account(source.getAccountId());

// Start building the transaction.
Transaction transaction = new Transaction.Builder(sourceAccount, Network.TESTNET)
        .addOperation(new PaymentOperation.Builder(destination.getAccountId(), new AssetTypeNative(), "10").build())
        // A memo allows you to add your own metadata to a transaction. It's
        // optional and does not affect how Stellar treats the transaction.
        .addMemo(Memo.text("Test Transaction"))
        // Wait a maximum of three minutes for the transaction
        .setTimeout(180)
        // Set the amount of lumens you're willing to pay per operation to submit your transaction
        .setBaseFee(Transaction.MIN_BASE_FEE)
        .build();
// Sign the transaction to prove you are actually the person sending it.
transaction.sign(source);

// And finally, send it off to Stellar!
try {
  SubmitTransactionResponse response = server.submitTransaction(transaction);
  System.out.println("Success!");
  System.out.println(response);
} catch (Exception e) {
  System.out.println("Something went wrong!");
  System.out.println(e.getMessage());
  // If the result is unknown (no response body, timeout etc.) we simply resubmit
  // already built transaction:
  // SubmitTransactionResponse response = server.submitTransaction(transaction);
}
```

```go
package main

import (
    "github.com/stellar/go/keypair"
    "github.com/stellar/go/network"
    "github.com/stellar/go/txnbuild"
    "github.com/stellar/go/clients/horizonclient"
    "fmt"
)

func main () {
    source := "SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4"
    destination := "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5"
    client := horizonclient.DefaultTestNetClient

    // Make sure destination account exists
    destAccountRequest := horizonclient.AccountRequest{AccountID: destination}
    destinationAccount, err := client.AccountDetail(destAccountRequest)
    if err != nil {
        panic(err)
    }

    fmt.Println("Destination Account", destinationAccount)

    // Load the source account
    sourceKP := keypair.MustParseFull(source)
    sourceAccountRequest := horizonclient.AccountRequest{AccountID: sourceKP.Address()}
    sourceAccount, err := client.AccountDetail(sourceAccountRequest)
    if err != nil {
        panic(err)
    }

    // Build transaction
    tx, err := txnbuild.NewTransaction(
      txnbuild.TransactionParams{
        SourceAccount:        &sourceAccount,
        IncrementSequenceNum: true,
        BaseFee:              txnbuild.MinBaseFee,
        Preconditions: txnbuild.Preconditions{
          TimeBounds: txnbuild.NewInfiniteTimeout(), // Use a real timeout in production!
        },
        Operations: []txnbuild.Operation{
          &txnbuild.Payment{
            Destination: destination,
            Amount:      "10",
            Asset:       txnbuild.NativeAsset{},
          },
        },
      },
    )

    if err != nil {
        panic(err)
    }

    // Sign the transaction to prove you are actually the person sending it.
    tx, err = tx.Sign(network.TestNetworkPassphrase, sourceKP)
    if err != nil {
        panic(err)
    }

    // And finally, send it off to Stellar!
    resp, err := horizonclient.DefaultTestNetClient.SubmitTransaction(tx)
    if err != nil {
        panic(err)
    }

    fmt.Println("Successful Transaction:")
    fmt.Println("Ledger:", resp.Ledger)
    fmt.Println("Hash:", resp.Hash)
}
```

```python
from stellar_sdk import Asset, Keypair, Network, Server, TransactionBuilder
from stellar_sdk.exceptions import NotFoundError, BadResponseError, BadRequestError

server = Server("https://horizon-testnet.stellar.org")
source_key = Keypair.from_secret("SCZANGBA5YHTNYVVV4C3U252E2B6P6F5T3U6MM63WBSBZATAQI3EBTQ4")
destination_id = "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5"

# First, check to make sure that the destination account exists.
# You could skip this, but if the account does not exist, you will be charged
# the transaction fee when the transaction fails.
try:
    server.load_account(destination_id)
except NotFoundError:
    # If the account is not found, surface an error message for logging.
    raise Exception("The destination account does not exist!")

# If there was no error, load up-to-date information on your account.
source_account = server.load_account(source_key.public_key)

# Let's fetch base_fee from network
base_fee = server.fetch_base_fee()

# Start building the transaction.
transaction = (
    TransactionBuilder(
        source_account=source_account,
        network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
        base_fee=base_fee,
    )
        # Because Stellar allows transaction in many currencies, you must specify the asset type.
        # Here we are sending Lumens.
        .append_payment_op(destination=destination_id, asset=Asset.native(), amount="10")
        # A memo allows you to add your own metadata to a transaction. It's
        # optional and does not affect how Stellar treats the transaction.
        .add_text_memo("Test Transaction")
        # Wait a maximum of three minutes for the transaction
        .set_timeout(10)
        .build()
)

# Sign the transaction to prove you are actually the person sending it.
transaction.sign(source_key)

try:
    # And finally, send it off to Stellar!
    response = server.submit_transaction(transaction)
    print(f"Response: {response}")
except (BadRequestError, BadResponseError) as err:
    print(f"Something went wrong!\n{err}")
```

</CodeExample>

#### Step-by-Step Breakdown

What exactly happened there? Let’s break it down.

1. Confirm that the account ID (aka the _public key_) you are sending to actually exists by loading the associated account data from the Stellar network. It's okay to skip this step, but it gives you an opportunity to avoid making a transaction that will inevitably fail.

<CodeExample>

```js
// Using RPC
rpc.getAccount(destinationId).then(function (account) {
  /* validate the account */
});

// Using Horizon
server.loadAccount(destinationId).then(function (account) {
  /* validate the account */
});
```

```java
server.accounts().account(destination.getAccountId());
```

```go
destAccountRequest := horizonclient.AccountRequest{AccountID: destination}
destinationAccount, err := client.AccountDetail(destAccountRequest)
if err != nil {
    panic(err)
}
fmt.Println("Destination Account", destinationAccount)
```

```python
server.load_account(destination_id)
```

</CodeExample>

2. Load data for the account you are sending from. An account can only perform one transaction at a time and has something called a [sequence number](../../../learn/glossary.mdx#sequence-number), which helps Stellar verify the order of transactions. A transaction’s sequence number needs to match the account’s sequence number, so you need to get the account’s current sequence number from the network.

<CodeExample>

```js
// Using RPC
rpc.getAccount(sourceKeys.publicKey()).then(function (sourceAccount) {
  /* use sourceAccount to build transaction */
});

// Using Horizon
server.loadAccount(sourceKeys.publicKey()).then(function (sourceAccount) {
  /* use sourceAccount to build transaction */
});
```

```java
AccountResponse sourceAccount = server.accounts().account(source.getAccountId());
```

```go
sourceKP := keypair.MustParseFull(source)
sourceAccountRequest := horizonclient.AccountRequest{AccountID: sourceKP.Address()}
sourceAccount, err := client.AccountDetail(sourceAccountRequest)
if err != nil {
  panic(err)
}
```

```python
source_account = server.load_account(source_key.public_key)
```

</CodeExample>

The SDK will automatically increment the account’s sequence number when you build a transaction, so you won’t need to retrieve this information again if you want to perform a second transaction.

3. Start building a transaction. This requires an account object, not just an account ID, because it will increment the account’s sequence number.

<CodeExample>

```js
var transaction = new StellarSdk.TransactionBuilder(sourceAccount);
```

```java
Transaction transaction = new Transaction.Builder(sourceAccount, Network.TESTNET)
```

```go
tx, err := txnbuild.NewTransaction(
  txnbuild.TransactionParams{
    SourceAccount:        &sourceAccount,
    IncrementSequenceNum: true,
    BaseFee:              MinBaseFee,
    Preconditions: txnbuild.Preconditions{
      TimeBounds: txnbuild.NewInfiniteTimeout(), // Use a real timeout in production!
    },
    ...
  },
)

if err != nil {
    panic(err)
}
```

```python
transaction = TransactionBuilder(
    source_account=source_account,
    network_passphrase=Network.TESTNET_NETWORK_PASSPHRASE,
    base_fee=base_fee
)
```

</CodeExample>

4. Add the payment operation to the account. Note that you need to specify the type of asset you are sending: Stellar’s network currency is the [lumen](https://www.stellar.org/lumens), but you can send any asset issued on the network. We'll cover sending non-lumen assets [below](#transacting-in-other-currencies). For now, though, we’ll stick to lumens, which are called “native” assets in the SDK:

<CodeExample>

```js
.addOperation(StellarSdk.Operation.payment({
  destination: destinationId,
  asset: StellarSdk.Asset.native(),
  amount: "10"
}))
```

```java
.addOperation(new PaymentOperation.Builder(destination.getAccountId(), new AssetTypeNative(), "10").build())
```

```go
Operations: []txnbuild.Operation{
    &txnbuild.Payment{
      Destination: destination,
      Amount:      "10",
      Asset:       txnbuild.NativeAsset{},
    },
  },
```

```python
.append_payment_op(destination=destination_id, asset=Asset.native(), amount="10")
```

</CodeExample>

You should also note that the amount is a string rather than a number. When working with extremely small fractions or large values, [floating point math can introduce small inaccuracies](https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems). Since not all systems have a native way to accurately represent extremely small or large decimals, Stellar uses strings as a reliable way to represent the exact amount across any system.

5. Optionally, you can add your own metadata, called a [memo](../../../learn/encyclopedia/transactions-specialized/memos.mdx), to a transaction. Stellar doesn’t do anything with this data, but you can use it for any purpose you’d like. Many exchanges require memos for incoming transactions because they use a single Stellar account for all their users and rely on the memo to differentiate between internal user accounts.

<CodeExample title="Add a Memo">

```js
.addMemo(StellarSdk.Memo.text('Test Transaction'))
```

```java
.addMemo(Memo.text("Test Transaction"));
```

```go
Memo: txnbuild.MemoText("Test Transaction")
```

```python
.add_text_memo("Test Transaction")
```

</CodeExample>

6. Now that the transaction has all the data it needs, you have to cryptographically sign it using your secret key. This proves that the data actually came from you and not someone impersonating you.

<CodeExample>

```js
transaction.sign(sourceKeys);
```

```java
transaction.sign(source);
```

```go
tx, err = tx.Sign(network.TestNetworkPassphrase, sourceKP)
if err != nil {
    panic(err)
}
```

```python
transaction.sign(source_key)
```

</CodeExample>

7. And finally, submit it to the Stellar network!

<CodeExample>

```js
// Using RPC - requires polling for final status
rpc
  .sendTransaction(transaction)
  .then(async (reply) => {
    if (reply.status !== "PENDING") {
      throw reply;
    }
    return rpc.pollTransaction(reply.hash);
  })
  .then((finalStatus) => {
    // Check status: SUCCESS, FAILED, or NOT_FOUND
    console.log("Final status:", finalStatus.status);
  });

// Using Horizon - returns final status immediately
server.submitTransaction(transaction).then((result) => {
  console.log("Success! Results:", result);
});
```

```java
server.submitTransaction(transaction);
```

```go
resp, err := horizonclient.DefaultTestNetClient.SubmitTransaction(tx)
if err != nil {
    panic(err)
}
```

```python
server.submit_transaction(transaction)
```

</CodeExample>

In this example, we're submitting the transaction to either the SDF-maintained public testnet instance of Horizon (the Stellar API) or to a Stellar RPC server. When submitting transactions to either a Horizon server or RPC server — which is what most people do — it's possible that you will not receive a response from the server due to a bug, network conditions, etc. In such a situation it's impossible to determine the status of your transaction.

That's why you should always save a built transaction (or transaction encoded in XDR format) in a variable or a database and resubmit it if you don't know its status. If the transaction has already been successfully applied to the ledger, both Horizon and RPC will simply return the saved result and not attempt to submit the transaction again. Only in cases where a transaction's status is unknown (and thus will have a chance of being included into a ledger) will a resubmission to the network occur.

### Receive a Payment

You don’t actually need to do anything to receive payments into a Stellar account: if a payer makes a successful transaction to send assets to you, those assets will automatically be added to your account.

However, you may want to keep an eye out for incoming payments. A simple program that watches the network for payments and prints each one might look like:

{/* Using RPC will be introduced later once we have events launched for classic asset effects */}

#### Using Horizon

<CodeExample title="Receive Payments">

```js
var StellarSdk = require("stellar-sdk");

var server = new StellarSdk.Horizon.Server(
  "https://horizon-testnet.stellar.org",
);
var accountId = "GC2BKLYOOYPDEFJKLKY6FNNRQMGFLVHJKQRGNSSRRGSMPGF32LHCQVGF";

// Create an API call to query payments involving the account.
var payments = server.payments().forAccount(accountId);

// If some payments have already been handled, start the results from the
// last seen payment. (See below in `handlePayment` where it gets saved.)
var lastToken = loadLastPagingToken();
if (lastToken) {
  payments.cursor(lastToken);
}

// `stream` will send each recorded payment, one by one, then keep the
// connection open and continue to send you new payments as they occur.
payments.stream({
  onmessage: function (payment) {
    // Record the paging token so we can start from here next time.
    savePagingToken(payment.paging_token);

    // The payments stream includes both sent and received payments. We only
    // want to process received payments here.
    if (payment.to !== accountId) {
      return;
    }

    // In Stellar’s API, Lumens are referred to as the “native” type. Other
    // asset types have more detailed information.
    var asset;
    if (payment.asset_type === "native") {
      asset = "lumens";
    } else {
      asset = payment.asset_code + ":" + payment.asset_issuer;
    }

    console.log(payment.amount + " " + asset + " from " + payment.from);
  },

  onerror: function (error) {
    console.error("Error in payment stream");
  },
});

function savePagingToken(token) {
  // In most cases, you should save this to a local database or file so that
  // you can load it next time you stream new payments.
}

function loadLastPagingToken() {
  // Get the last paging token from a local database or file
}
```

```java
Server server = new Server("https://horizon-testnet.stellar.org");
KeyPair account = KeyPair.fromAccountId("GC2BKLYOOYPDEFJKLKY6FNNRQMGFLVHJKQRGNSSRRGSMPGF32LHCQVGF");

// Create an API call to query payments involving the account.
PaymentsRequestBuilder paymentsRequest = server.payments().forAccount(account.getAccountId());

// If some payments have already been handled, start the results from the
// last seen payment. (See below in `handlePayment` where it gets saved.)
String lastToken = loadLastPagingToken();
if (lastToken != null) {
  paymentsRequest.cursor(lastToken);
}

// `stream` will send each recorded payment, one by one, then keep the
// connection open and continue to send you new payments as they occur.
paymentsRequest.stream(new EventListener<OperationResponse>() {
  @Override
  public void onEvent(OperationResponse payment) {
    // Record the paging token so we can start from here next time.
    savePagingToken(payment.getPagingToken());

    // The payments stream includes both sent and received payments. We only
    // want to process received payments here.
    if (payment instanceof PaymentOperationResponse) {
      if (!((PaymentOperationResponse) payment).getTo().equals(account.getAccountId()) {
        return;
      }

      String amount = ((PaymentOperationResponse) payment).getAmount();

      Asset asset = ((PaymentOperationResponse) payment).getAsset();
      String assetName;
      if (asset.equals(new AssetTypeNative())) {
        assetName = "lumens";
      } else {
        StringBuilder assetNameBuilder = new StringBuilder();
        assetNameBuilder.append(((AssetTypeCreditAlphaNum) asset).getCode());
        assetNameBuilder.append(":");
        assetNameBuilder.append(((AssetTypeCreditAlphaNum) asset).getIssuer());
        assetName = assetNameBuilder.toString();
      }

      StringBuilder output = new StringBuilder();
      output.append(amount);
      output.append(" ");
      output.append(assetName);
      output.append(" from ");
      output.append(((PaymentOperationResponse) payment).getFrom());
      System.out.println(output.toString());
    }
  }

  @Override
  public void onFailure(Optional<Throwable> optional, Optional<Integer> optional1) {

  }
});
```

```go
package main

import (
    "context"
    "fmt"
    "time"

    "github.com/stellar/go/clients/horizonclient"
    "github.com/stellar/go/protocols/horizon/operations"
)

func main() {
    client := horizonclient.DefaultTestNetClient
    opRequest := horizonclient.OperationRequest{ForAccount: "GC2BKLYOOYPDEFJKLKY6FNNRQMGFLVHJKQRGNSSRRGSMPGF32LHCQVGF", Cursor: "now"}

    ctx, cancel := context.WithCancel(context.Background())
    go func() {
        // Stop streaming after 60 seconds.
        time.Sleep(60 * time.Second)
        cancel()
    }()

    printHandler := func(op operations.Operation) {
        fmt.Println(op)
    }
    err := client.StreamPayments(ctx, opRequest, printHandler)
    if err != nil {
        fmt.Println(err)
    }

}
```

```python
from stellar_sdk import Server

def load_last_paging_token():
    # Get the last paging token from a local database or file
    return "now"

def save_paging_token(paging_token):
    # In most cases, you should save this to a local database or file so that
    # you can load it next time you stream new payments.
    pass

server = Server("https://horizon-testnet.stellar.org")
account_id = "GC2BKLYOOYPDEFJKLKY6FNNRQMGFLVHJKQRGNSSRRGSMPGF32LHCQVGF"

# Create an API call to query payments involving the account.
payments = server.payments().for_account(account_id)

# If some payments have already been handled, start the results from the
# last seen payment. (See below in `handle_payment` where it gets saved.)
last_token = load_last_paging_token()
if last_token:
    payments.cursor(last_token)

# `stream` will send each recorded payment, one by one, then keep the
# connection open and continue to send you new payments as they occur.
for payment in payments.stream():
    # Record the paging token so we can start from here next time.
    save_paging_token(payment["paging_token"])

    # We only process `payment`, ignore `create_account` and `account_merge`.
    if payment["type"] != "payment":
        continue

    # The payments stream includes both sent and received payments. We
    # only want to process received payments here.
    if payment['to'] != account_id:
        continue

    # In Stellar’s API, Lumens are referred to as the “native” type. Other
    # asset types have more detailed information.
    if payment["asset_type"] == "native":
        asset = "Lumens"
    else:
        asset = f"{payment['asset_code']}:{payment['asset_issuer']}"
    print(f"{payment['amount']} {asset} from {payment['from']}")
```

</CodeExample>

There are two main parts to this program. First, you create a query for payments involving a given account. Like most queries in Stellar, this could return a huge number of items, so the API returns paging tokens, which you can use later to start your query from the same point where you previously left off. In the example above, the functions to save and load paging tokens are left blank, but in a real application, you’d want to save the paging tokens to a file or database so you can pick up where you left off in case the program crashes or the user closes it.

<CodeExample>

```js
var payments = server.payments().forAccount(accountId);
var lastToken = loadLastPagingToken();
if (lastToken) {
  payments.cursor(lastToken);
}
```

```java
PaymentsRequestBuilder paymentsRequest = server.payments().forAccount(account.getAccountId());
String lastToken = loadLastPagingToken();
if (lastToken != null) {
  paymentsRequest.cursor(lastToken);
}
```

```go
client := horizonclient.DefaultTestNetClient
opRequest := horizonclient.OperationRequest{ForAccount: "GC2BKLYOOYPDEFJKLKY6FNNRQMGFLVHJKQRGNSSRRGSMPGF32LHCQVGF", Cursor: "now"}
```

```python
payments = server.payments().for_account(account_id)
last_token = load_last_paging_token()
if last_token:
    payments.cursor(last_token)
```

</CodeExample>

Second, the results of the query are streamed. This is the easiest way to watch for payments or other transactions. Each existing payment is sent through the stream, one by one. Once all existing payments have been sent, the stream stays open and new payments are sent as they are made.

Try it out: Run this program, and then, in another window, create and submit a payment. You should see this program log the payment.

<CodeExample>

```js
payments.stream({
  onmessage: function (payment) {
    // handle a payment
  },
});
```

```java
paymentsRequest.stream(new EventListener<OperationResponse>() {
  @Override
  public void onEvent(OperationResponse payment) {
    // Handle a payment
  }
});
```

```go
ctx, cancel := context.WithCancel(context.Background())
go func() {
    // Stop streaming after 60 seconds.
    time.Sleep(60 * time.Second)
    cancel()
}()

printHandler := func(op operations.Operation) {
    fmt.Println(op)
}
err := client.StreamPayments(ctx, opRequest, printHandler)
if err != nil {
    fmt.Println(err)
}
```

```python
for payment in payments.stream():
    # handle a payment
```

</CodeExample>

You can also request payments in groups or pages. Once you’ve processed each page of payments, you’ll need to request the next one until there are none left.

<CodeExample>

```js
payments.call().then(function handlePage(paymentsPage) {
  paymentsPage.records.forEach(function (payment) {
    // handle a payment
  });
  return paymentsPage.next().then(handlePage);
});
```

```java
Page<OperationResponse> page = payments.execute();

for (OperationResponse operation : page.getRecords()) {
    // handle a payment
}

page = page.getNextPage();
```

```python
payments_current = payments.call()
payments_next = payments.next()
```

</CodeExample>

## Stellar Asset Contract (SAC) Payments

When sending payments using Stellar Asset Contracts, you invoke smart contract functions instead of using classic payment operations. SAC payments utilize the `invokeHostFunction` operation to call contract methods like `transfer`, which provides the same payment functionality but through contract logic. This approach offers additional flexibility and programmability while maintaining compatibility with Stellar's asset system.

In the example below, we're using SAC as a smart contract interface for the native asset, so the end result is the same as if a native payment operation had been executed. However, the same process can be applied for any smart contract transfer involving standardized custom tokens that follow the [custom token interface](../../../tokens/token-interface.mdx). This makes SAC payments a unified approach for handling both native assets and custom tokens through a consistent contract-based interface.

Here's how you might send 10 lumens using a SAC:

<Alert>
  To use the RPC example below you should first generate the contract bindings so the
  client can be used accordingly. This can be achieved through the [Stellar
  CLI](../../../tools/cli/README.mdx).

E.g.: Generating the typescript bindings for the `sac` contract of a given asset:

```bash
 stellar contract bindings typescript --network=testnet --contract-id=CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC --output-dir=./bindings
```

</Alert>

### Send a Payment

<CodeExample>

```js
import { Asset, Keypair, Networks, TransactionBuilder } from "stellar-sdk";
import { Client } from "sac";

// Source account secret key (in production, store this securely)
const sourceKeys = Keypair.fromSecret(
  "SAMAJBEGN2743SLFDSBSVRCTQ7AC33XFZHWJVCJ2UMOIVH4MUJ7WWHEJ",
);

// Destination account public key
const destinationId =
  "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5";

// Create a SAC client for native XLM using the contract address
// This client can be generated using the Stellar CLI to create bindings
// for a given contract.
const xlmClient = new Client({
  rpcUrl: "https://soroban-testnet.stellar.org",
  networkPassphrase: Networks.TESTNET,
  contractId: Asset.native().contractId(Networks.TESTNET),
  publicKey: sourceKeys.publicKey(),
  // Custom transaction signing function
  signTransaction: async (txXdr) => {
    const tx = await TransactionBuilder.fromXDR(txXdr, Networks.TESTNET);
    tx.sign(sourceKeys);
    return {
      signedTxXdr: tx.toXDR(),
      signerAddress: sourceKeys.publicKey(),
    };
  },
});

// Execute the SAC transfer operation
xlmClient
  .transfer({
    to: destinationId,
    amount: BigInt(10_0000000), // Amount in stroops (1 XLM = 10,000,000 stroops)
    from: sourceKeys.publicKey(),
  })
  .then((tx) => {
    // Sign and submit the transaction to the network
    tx.signAndSend()
      .then((result) => {
        console.log(
          "Transaction successful:",
          result.getTransactionResponse?.txHash,
        );
      })
      .catch((error) => {
        console.error("Transaction failed:", error);
      });
  })
  .catch((error) => {
    console.error("Error during transfer:", error);
  });
```

</CodeExample>

#### Step-by-Step Breakdown

What exactly happened in the SAC payment example? Let's break it down:

1. Import the generated contract client from the CLI-produced bindings. This client provides typed methods for interacting with the Stellar Asset Contract.

<CodeExample>

```js
import { Client } from "sac";
```

</CodeExample>

2. Initialize the SAC client with connection details and a custom signing function. The client needs the RPC endpoint, network passphrase, contract ID for the asset, and your account's public key. A signing function can also be provided to automatically handle transaction signing when invoking contract methods with this client.

<CodeExample>

```js
const xlmClient = new Client({
  rpcUrl: "https://soroban-testnet.stellar.org",
  networkPassphrase: Networks.TESTNET,
  contractId: Asset.native().contractId(Networks.TESTNET),
  publicKey: sourceKeys.publicKey(),
  signTransaction: async (txXdr) => {
    const tx = await TransactionBuilder.fromXDR(txXdr, Networks.TESTNET);
    tx.sign(sourceKeys);
    return {
      signedTxXdr: tx.toXDR(),
      signerAddress: sourceKeys.publicKey(),
    };
  },
});
```

</CodeExample>

3. Initiate the transfer by calling the contract's `transfer` method. This returns an assembled transaction ready for signing and submission.

<CodeExample>

```js
xlmClient.transfer({
  to: destinationId,
  amount: BigInt(10_0000000), // Amount in stroops (1 XLM = 10,000,000 stroops)
  from: sourceKeys.publicKey(),
});
```

</CodeExample>

4. Sign and submit the transaction using `signAndSend()`. The client handles simulation, signing (using your provided function), submission to the network, and polling for the final result.

<CodeExample>

```js
.then((tx) => {
  tx.signAndSend()
    .then((result) => {
      console.log("Transaction successful:", result.getTransactionResponse?.txHash);
    })
    .catch((error) => {
      console.error("Transaction failed:", error);
    });
})
```

</CodeExample>

### Receive a Payment

You don't need to do anything special to receive SAC payments into a Stellar account: if a payer makes a successful contract transfer to you, those assets will automatically be added to your account.

However, you may want to monitor for incoming SAC payments. Since SAC payments generate contract events rather than traditional payment operations, you'll need to watch for contract events instead of using Horizon's payment streams. Here's how you can monitor for incoming Smart Contract transfers:

<CodeExample>

```js
import { Server } from "stellar-sdk/rpc";
import { xdr, Asset, Networks, Address } from "stellar-sdk";

// RPC server for testnet
const rpc = new Server("https://soroban-testnet.stellar.org");

// Get the native XLM contract ID for testnet
const contractId = Asset.native().contractId(Networks.TESTNET);

// The address we want to monitor for incoming payments
const monitoredAddress = new Address(
  "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5"
);

// Paging state for event polling (similar to useSubscription hook)
let lastLedgerStart: number | undefined;
let pagingToken: string | undefined;

async function pollForTransfers() {
  try {
    // Set starting ledger if not set (get the latest ledger as starting point)
    if (!lastLedgerStart) {
      const latestLedger = await rpc.getLatestLedger();
      lastLedgerStart = latestLedger.sequence;
    }
    console.log(`> Monitoring transfers for ledger: ${lastLedgerStart}`);

    // Get events for "transfer" topic from the native asset contract
    const response = await rpc.getEvents({
      startLedger: !pagingToken ? lastLedgerStart : undefined,
      cursor: pagingToken,
      filters: [
        {
          contractIds: [contractId],
          // Filter for transfer events to the monitored address
          // Using wildcards (*) to match any sender and asset
          // Event structure: ["transfer", fromAddress, toAddress, assetName]
          topics: [
            [
              xdr.ScVal.scvSymbol("transfer").toXDR("base64"),
              "*",
              monitoredAddress.toScVal().toXDR("base64"),
              "*",
            ],
          ],
          type: "contract",
        },
      ],
      limit: 10,
    });

    // Update paging tokens for next poll
    pagingToken = undefined;
    if (response.latestLedger) {
      lastLedgerStart = response.latestLedger;
    }

    // Process events and check for payments to our monitored address
    if (response.events) {
      response.events.forEach((event) => {
        try {
          const topics = event.topic;
          console.log(
            `📜 Processing event: ${event.txHash} at ledger ${event.ledger}`
          );
          if (topics && topics.length >= 3) {
            // Extract recipient address from event topics
            const toAddress = Address.fromScAddress(
              topics[2].address()
            ).toString();

            // Check if the payment is to our monitored address
            if (toAddress === monitoredAddress.toString()) {
              console.log("PAYMENT RECEIVED!");
              console.log(`  Transaction: ${event.txHash}`);
              console.log(`  Ledger: ${event.ledger}`);
              console.log(
                `  Sender: ${Address.fromScAddress(
                  topics[1].address()
                ).toString()}`
              );
              console.log(`  Amount: ${event.value.i128().lo().toBigInt()}`);
            }
          }
        } catch (error) {
          console.error("Error processing event:", error);
        } finally {
          // Update paging token for next poll
          pagingToken = event.pagingToken;
        }
      });
    }
  } catch (error) {
    console.error("Poll Events error:", error);
  } finally {
    // Continue polling after 4 seconds
    setTimeout(pollForTransfers, 4000);
  }
}

// Start monitoring for payment events
console.log(`Starting payment monitor for: ${monitoredAddress}`);
pollForTransfers();
```

</CodeExample>

#### Step-by-Step Breakdown

What exactly happened in the SAC receive payment example? Let's break it down:

1. Set up the RPC connection and get the contract ID for the asset you want to monitor. For native XLM, we use the built-in contract ID.

<CodeExample>

```js
const rpc = new Server("https://soroban-testnet.stellar.org");
const contractId = Asset.native().contractId(Networks.TESTNET);
const monitoredAddress = new Address(
  "GA2C5RFPE6GCKMY3US5PAB6UZLKIGSPIUKSLRB6Q723BM2OARMDUYEJ5",
);
```

</CodeExample>

2. Initialize the polling system by getting the latest ledger sequence as a starting point for monitoring events.

<CodeExample>

```js
if (!lastLedgerStart) {
  const latestLedger = await rpc.getLatestLedger();
  lastLedgerStart = latestLedger.sequence;
}
```

</CodeExample>

3. Query contract events using specific filters for transfer events. The filter targets the contract ID and listens for "transfer" events where your address is the recipient. The topics array defines the event structure: the first element is the event name ("transfer"), the second is the sender (wildcard "_" to match any), the third is the recipient (your monitored address), and the fourth is the asset (wildcard "_" for any asset).

<CodeExample>

```js
const response = await rpc.getEvents({
  startLedger: !pagingToken ? lastLedgerStart : undefined,
  cursor: pagingToken,
  filters: [
    {
      contractIds: [contractId],
      // Topics filter structure: ["event_name", "from_address", "to_address", "asset"]
      // Using wildcards (*) allows matching any value in that position
      topics: [
        [
          xdr.ScVal.scvSymbol("transfer").toXDR("base64"), // Event name: "transfer"
          "*", // From: any address
          monitoredAddress.toScVal().toXDR("base64"), // To: our monitored address
          "*", // Asset: any asset
        ],
      ],
      type: "contract",
    },
  ],
  limit: 10,
});
```

</CodeExample>

4. Process the events by extracting transfer details from the event topics and values, then continue polling for new events after a short delay.

<CodeExample>

```js
response.events.forEach((event) => {
  const topics = event.topic;
  if (topics && topics.length >= 3) {
    const toAddress = Address.fromScAddress(topics[2].address()).toString();

    if (toAddress === monitoredAddress.toString()) {
      console.log("PAYMENT RECEIVED!");
      console.log(`Amount: ${event.value.i128().lo().toBigInt()}`);
    }
  }
});

// Continue polling
setTimeout(pollForTransfers, 4000);
```

</CodeExample>

**Key Differences from Classic Payment Monitoring:**

- **Event-based**: Monitors contract events instead of payment operations
- **RPC Only**: Uses RPC endpoints exclusively, no Horizon support
- **Topic Filtering**: Uses event topics to filter for specific transfer patterns
- **Active Polling**: Requires continuous polling rather than streaming
- **Event Structure**: Extracts payment data from contract event topics and values rather than operation fields

## Transacting in Other Currencies

One of the amazing things about the Stellar network is that you can create, hold, send, receive, and trade any type of asset. Many organizations issue assets on Stellar that represent real-world currencies such as US dollars or Nigerian naira or other cryptocurrencies such as bitcoin or ether.

Each of these redeemable assets — _anchored_ in the Stellar vernacular — is essentially a credit issued by a particular account that represents reserves those accounts hold outside the network. That's why the assets in the example above had both a `code` and an `issuer`: the `issuer` is the public key of the account that created the asset, an account owned by the organization that ultimately honors the credit that asset represents.
